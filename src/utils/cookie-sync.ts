import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { URL } from 'node:url';
import { type BrowserContext, type Cookie, chromium, firefox, webkit } from 'playwright';
import type { ResolvedConfig } from '../config/config-schema.js';
import { logger } from './logger.js';

type NetscapeCookie = {
  domain: string;
  includeSubdomains: boolean;
  path: string;
  secure: boolean;
  expiry: number;
  name: string;
  value: string;
};

function parseNetscapeCookies(content: string): NetscapeCookie[] {
  const lines = content.split('\n');
  const cookies: NetscapeCookie[] = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const parts = trimmed.split('\t');
    if (parts.length < 7) continue;
    const [domain = '', flag = 'FALSE', path = '/', secure = 'FALSE', expiry = '0', name = '', value = ''] = parts;
    cookies.push({
      domain,
      includeSubdomains: flag.toUpperCase() === 'TRUE',
      path,
      secure: secure.toUpperCase() === 'TRUE',
      expiry: Number(expiry) || 0,
      name,
      value,
    });
  }
  return cookies;
}

function toPlaywrightCookies(nc: NetscapeCookie[]): Cookie[] {
  return nc.map((c) => ({
    name: c.name,
    value: c.value,
    domain: c.domain,
    path: c.path || '/',
    expires: c.expiry || -1,
    httpOnly: false,
    secure: c.secure,
    sameSite: 'Lax',
  }));
}

function serializeNetscapeCookies(cookies: Cookie[]): string {
  const lines: string[] = [];
  lines.push('# Netscape HTTP Cookie File');
  lines.push('# This file is generated by Wetvlo via Playwright. Do not edit.');
  lines.push('');
  for (const c of cookies) {
    const domain = c.domain || '';
    const includeSubdomains = domain.startsWith('.') ? 'TRUE' : 'FALSE';
    const path = c.path || '/';
    const secure = c.secure ? 'TRUE' : 'FALSE';
    const expires = typeof c.expires === 'number' ? Math.max(0, Math.floor(c.expires)) : 0;
    const name = c.name;
    const value = c.value;
    lines.push([domain, includeSubdomains, path, secure, String(expires), name, value].join('\t'));
  }
  return lines.join('\n');
}

function mapBrowserToPlaywright(browser?: string) {
  switch ((browser || 'chrome').toLowerCase()) {
    case 'chrome':
    case 'chromium':
    case 'edge':
      return chromium;
    case 'firefox':
      return firefox;
    case 'safari':
      return webkit;
    default:
      return chromium;
  }
}

async function loadCookiesIntoContext(context: BrowserContext, cookieFile: string): Promise<void> {
  if (!existsSync(cookieFile)) {
    logger.warning(`Cookie file not found at ${cookieFile}, skipping import`);
    return;
  }
  const content = await readFile(cookieFile, 'utf-8');
  const netscape = parseNetscapeCookies(content);
  const playwrightCookies = toPlaywrightCookies(netscape);
  if (playwrightCookies.length > 0) {
    await context.addCookies(playwrightCookies);
    logger.info(`Imported ${playwrightCookies.length} cookies into Playwright context`);
  }
}

async function saveContextCookies(context: BrowserContext, cookieFile: string, seriesUrl: string): Promise<void> {
  // Limit to cookies relevant to the series domain to reduce noise
  const { hostname } = new URL(seriesUrl);
  const all = await context.cookies();
  const relevant = all.filter((c) => {
    const domain = (c.domain || '').replace(/^\./, '');
    return domain === hostname || hostname.endsWith(domain);
  });
  const serialized = serializeNetscapeCookies(relevant);
  await writeFile(cookieFile, serialized, 'utf-8');
  logger.success(`Saved ${relevant.length} cookies to ${cookieFile}`);
}

export async function refreshCookiesWithPlaywright(seriesUrl: string, config: ResolvedConfig<'series'>): Promise<void> {
  const cookieFile = config.cookieFile;
  if (!cookieFile) {
    logger.debug('No cookieFile configured, skipping cookie refresh');
    return;
  }

  const refreshBrowser = config.cookieRefreshBrowser;
  if (!refreshBrowser) {
    logger.debug('No cookieRefreshBrowser configured, skipping cookie refresh');
    return;
  }

  const headless = config.playwrightHeadless ?? true;
  const browserType = mapBrowserToPlaywright(refreshBrowser);

  const browser = await browserType.launch({ headless });
  try {
    const context = await browser.newContext();
    await loadCookiesIntoContext(context, cookieFile);
    const page = await context.newPage();
    await page.goto(seriesUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });
    await page.waitForLoadState('networkidle', { timeout: 15000 }).catch(() => {});
    await saveContextCookies(context, cookieFile, seriesUrl);
    await context.close();
  } finally {
    await browser.close();
  }
}
